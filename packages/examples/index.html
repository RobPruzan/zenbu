<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Juicy Brick Breaker</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: #080810; /* Darker background */
        color: white;
        font-family: Arial, sans-serif;
        min-height: 100vh;
        overflow: hidden; /* Prevent scrolling */
      }
      h1 {
        color: #ff6b6b;
        text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        margin-bottom: 10px;
      }
      canvas {
        background-color: rgba(20, 20, 30, 0.7); /* Darker canvas background */
        border-radius: 8px;
        box-shadow: 0 0 40px rgba(255, 107, 255, 0.6); /* More intense glow */
        margin-bottom: 20px;
        position: relative;
        z-index: 10;
      }
      .game-info {
        display: flex;
        justify-content: space-between;
        width: 800px;
        margin-bottom: 10px;
        z-index: 10;
        position: relative;
      }
      .score,
      .lives {
        font-size: 20px;
        font-weight: bold;
      }
      .controls {
        margin-top: 20px;
        background-color: rgba(42, 42, 42, 0.8);
        padding: 15px;
        border-radius: 8px;
        max-width: 800px;
        text-align: center;
        position: relative;
        z-index: 10;
      }
      .controls p {
        margin: 5px 0;
      }
      button {
        background-color: #ff6b6b;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        font-size: 16px;
        cursor: pointer;
        margin-top: 10px;
        transition: all 0.2s;
      }
      button:hover {
        background-color: #ff8787;
        transform: scale(1.05);
      }
      .game-container {
        position: relative;
        z-index: 5;
      }

      #background-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <canvas id="background-canvas"></canvas>
    <div class="game-container">
      <h1>Juicy Brick Breaker</h1>

      <div class="game-info">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="lives">Lives: <span id="lives">3</span></div>
      </div>

      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <button id="startButton">Start Game</button>

      <div class="controls">
        <p>Use left and right arrow keys or mouse to move the paddle</p>
        <p>Break all bricks to win!</p>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Background canvas setup
        const bgCanvas = document.getElementById("background-canvas");
        const dpr = window.devicePixelRatio;
        const rect = bgCanvas.getBoundingClientRect();

        // Set the "actual" size of the canvas
        bgCanvas.width = window.innerWidth * dpr;
        bgCanvas.height = window.innerHeight * dpr;

        // Scale the context to ensure correct drawing operations
        const bgCtx = bgCanvas.getContext("2d");
        bgCtx.scale(dpr, dpr);

        // Set the "drawn" size of the canvas
        bgCanvas.style.width = `${window.innerWidth}px`;
        bgCanvas.style.height = `${window.innerHeight}px`;

        // Background particles
        const bgParticles = [];
        const stars = [];
        const nebulae = [];
        const particleCount = 150;
        const starCount = 300;
        const nebulaCount = 10; // Increased nebula count

        class BackgroundParticle {
          constructor() {
            this.reset();
            // Start particles at random positions
            this.x = (Math.random() * bgCanvas.width) / dpr;
            this.y = (Math.random() * bgCanvas.height) / dpr;
          }

          reset() {
            this.x = (Math.random() * bgCanvas.width) / dpr;
            this.y = (Math.random() * bgCanvas.height) / dpr;
            this.size = Math.random() * 2 + 0.5;
            this.speedX = Math.random() * 0.3 - 0.15;
            this.speedY = Math.random() * 0.3 - 0.15;
            this.color = this.getRandomColor();
            this.alpha = Math.random() * 0.5 + 0.2;
            this.twinkleSpeed = Math.random() * 0.03;
            this.twinkleDirection = Math.random() > 0.5 ? 1 : -1;
            this.minAlpha = Math.random() * 0.2;
            this.maxAlpha = Math.min(this.alpha + 0.3, 1);
          }
          getRandomColor() {
            // Even darker, more spacey colors for background particles
            const colors = [
              "#1a2a4a", // Darker Blue
              "#2a1a4a", // Darker Purple
              "#0f3a39", // Darker Teal
              "#2a2a5f", // Darker Slate Blue
              "#4a2a4a", // Darker Magenta
            ];
            return colors[Math.floor(Math.random() * colors.length)];
          }

          update() {
            this.x += this.speedX;
            this.y += this.speedY;

            // Twinkle effect
            this.alpha += this.twinkleSpeed * this.twinkleDirection;
            if (this.alpha <= this.minAlpha || this.alpha >= this.maxAlpha) {
              this.twinkleDirection *= -1;
            }

            // Wrap around edges
            if (this.x < 0) this.x = bgCanvas.width / dpr;
            if (this.x > bgCanvas.width / dpr) this.x = 0;
            if (this.y < 0) this.y = bgCanvas.height / dpr;
            if (this.y > bgCanvas.height / dpr) this.y = 0;
          }

          draw() {
            bgCtx.globalAlpha = this.alpha;
            bgCtx.beginPath();
            bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            bgCtx.fillStyle = this.color;
            bgCtx.fill();

            // Add glow effect
            const glow = bgCtx.createRadialGradient(
              this.x,
              this.y,
              0,
              this.x,
              this.y,
              this.size * 3
            );
            glow.addColorStop(0, this.color);
            glow.addColorStop(1, "transparent");

            bgCtx.globalAlpha = this.alpha * 0.3;
            bgCtx.beginPath();
            bgCtx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
            bgCtx.fillStyle = glow;
            bgCtx.fill();

            bgCtx.globalAlpha = 1;
          }
        }

        class Star {
          constructor() {
            this.x = (Math.random() * bgCanvas.width) / dpr;
            this.y = (Math.random() * bgCanvas.height) / dpr;
            this.size = Math.random() * 1.2 + 0.2;
            this.alpha = Math.random() * 0.8 + 0.2;
            this.twinkleSpeed = Math.random() * 0.02 + 0.005;
            this.twinkleDirection = Math.random() > 0.5 ? 1 : -1;
            this.minAlpha = Math.max(0.1, this.alpha - 0.3);
            this.maxAlpha = Math.min(this.alpha + 0.3, 1);
          }

          update() {
            // Twinkle effect
            this.alpha += this.twinkleSpeed * this.twinkleDirection;
            if (this.alpha <= this.minAlpha || this.alpha >= this.maxAlpha) {
              this.twinkleDirection *= -1;
            }
          }

          draw() {
            bgCtx.globalAlpha = this.alpha;
            bgCtx.beginPath();
            bgCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            bgCtx.fillStyle = "#ffffff";
            bgCtx.fill();

            // Add star rays for larger stars
            if (this.size > 1) {
              const rayLength = this.size * 4;
              bgCtx.globalAlpha = this.alpha * 0.5;
              bgCtx.beginPath();
              bgCtx.moveTo(this.x - rayLength, this.y);
              bgCtx.lineTo(this.x + rayLength, this.y);
              bgCtx.moveTo(this.x, this.y - rayLength);
              bgCtx.lineTo(this.x, this.y + rayLength);
              bgCtx.strokeStyle = "#ffffff";
              bgCtx.lineWidth = 0.5;
              bgCtx.stroke();
            }

            bgCtx.globalAlpha = 1;
          }
        }

        class Nebula {
          constructor() {
            this.x = (Math.random() * bgCanvas.width) / dpr;
            this.y = (Math.random() * bgCanvas.height) / dpr;
            this.radius = Math.random() * 200 + 75; // Slightly larger nebulae range
            this.color = this.getRandomColor();
            this.alpha = Math.random() * 0.08 + 0.03; // Slightly lower alpha for subtlety
            this.pulseSpeed = Math.random() * 0.004 + 0.0005; // Slower pulse
            this.pulseDirection = Math.random() > 0.5 ? 1 : -1;
            this.minAlpha = Math.max(0.01, this.alpha - 0.04); // Lower min alpha
            this.maxAlpha = Math.min(this.alpha + 0.04, 0.15); // Lower max alpha
          }
          getRandomColor() {
            // Even darker, deeper nebula colors
            const colors = [
              "#1a0535", // Deeper Purple
              "#05091b", // Extremely Dark Blue
              "#0c1221", // Darker Navy
              "#1a304b", // Darker Slate Blue/Grey
              "#050508", // Near Black
              "#2b0052", // Darker Indigo
              "#35115b", // Darker Purple
            ];
            return colors[Math.floor(Math.random() * colors.length)];
          }

          update() {
            // Pulse effect
            this.alpha += this.pulseSpeed * this.pulseDirection;
            if (this.alpha <= this.minAlpha || this.alpha >= this.maxAlpha) {
              this.pulseDirection *= -1;
            }
          }

          draw() {
            const gradient = bgCtx.createRadialGradient(
              this.x,
              this.y,
              0,
              this.x,
              this.y,
              this.radius
            );
            gradient.addColorStop(0, this.color);
            gradient.addColorStop(1, "transparent");

            bgCtx.globalAlpha = this.alpha;
            bgCtx.beginPath();
            bgCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            bgCtx.fillStyle = gradient;
            bgCtx.fill();
            bgCtx.globalAlpha = 1;
          }
        }

        // Initialize background elements
        for (let i = 0; i < particleCount; i++) {
          bgParticles.push(new BackgroundParticle());
        }

        for (let i = 0; i < starCount; i++) {
          stars.push(new Star());
        }

        for (let i = 0; i < nebulaCount; i++) {
          nebulae.push(new Nebula());
        }

        function animateBackground() {
          bgCtx.clearRect(0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);

          // Draw a darker, deeper space gradient background
          const gradient = bgCtx.createLinearGradient(
            0,
            0,
            0,
            bgCanvas.height / dpr
          );
          gradient.addColorStop(0, "#030308"); // Even darker near-black blue
          gradient.addColorStop(0.5, "#05060a"); // Darker blue/purple
          gradient.addColorStop(1, "#080810"); // Deeper dark purple
          bgCtx.fillStyle = gradient;
          bgCtx.fillRect(0, 0, bgCanvas.width / dpr, bgCanvas.height / dpr);

          // Draw nebulae (behind everything)
          for (let i = 0; i < nebulae.length; i++) {
            nebulae[i].update();
            nebulae[i].draw();
          }

          // Draw stars
          for (let i = 0; i < stars.length; i++) {
            stars[i].update();
            stars[i].draw();
          }

          // Update and draw particles
          for (let i = 0; i < bgParticles.length; i++) {
            bgParticles[i].update();
            bgParticles[i].draw();
          }

          // Occasionally add a shooting star
          if (Math.random() < 0.01) {
            createShootingStar();
          }

          requestAnimationFrame(animateBackground);
        }

        function createShootingStar() {
          const x = (Math.random() * bgCanvas.width) / dpr;
          const y = 0;
          const length = Math.random() * 100 + 50;
          const angle = Math.PI / 4 + (Math.random() * Math.PI) / 4;
          const speed = Math.random() * 5 + 5;

          let currentX = x;
          let currentY = y;
          let traveled = 0;

          function drawShootingStar() {
            const tailLength = Math.min(traveled, length);

            // Draw the shooting star
            bgCtx.beginPath();
            bgCtx.moveTo(currentX, currentY);
            bgCtx.lineTo(
              currentX - tailLength * Math.cos(angle),
              currentY - tailLength * Math.sin(angle)
            );

            const gradient = bgCtx.createLinearGradient(
              currentX,
              currentY,
              currentX - tailLength * Math.cos(angle),
              currentY - tailLength * Math.sin(angle)
            );
            gradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
            gradient.addColorStop(1, "rgba(255, 255, 255, 0)");

            bgCtx.strokeStyle = gradient;
            bgCtx.lineWidth = 2;
            bgCtx.stroke();

            // Move the shooting star
            currentX += speed * Math.cos(angle);
            currentY += speed * Math.sin(angle);
            traveled += speed;

            // Continue animation until it goes off screen
            if (
              currentX < bgCanvas.width / dpr &&
              currentY < bgCanvas.height / dpr &&
              traveled < length + 100
            ) {
              requestAnimationFrame(drawShootingStar);
            }
          }

          drawShootingStar();
        }

        // Start background animation
        animateBackground();

        // Handle window resize for background
        window.addEventListener("resize", () => {
          const dpr = window.devicePixelRatio;
          bgCanvas.width = window.innerWidth * dpr;
          bgCanvas.height = window.innerHeight * dpr;
          bgCtx.scale(dpr, dpr);
          bgCanvas.style.width = `${window.innerWidth}px`;
          bgCanvas.style.height = `${window.innerHeight}px`;
        });
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const startButton = document.getElementById("startButton");
        const scoreElement = document.getElementById("score");
        const livesElement = document.getElementById("lives");

        // Juicy effects variables
        let screenShakeIntensity = 0;
        let screenShakeDuration = 0;
        let paddleSquashFactor = 1;
        let paddleSquashDuration = 0;
        let scorePopScale = 1;
        const ballTrail = [];
        const MAX_TRAIL_LENGTH = 15;
        let lastPaddleHitTime = 0;
        const PADDLE_HIT_COOLDOWN = 100; // milliseconds
        let lastWallHitTime = 0;
        const WALL_HIT_COOLDOWN = 50; // milliseconds
        // Time slow-motion effect variables
        let isSlowMotionActive = false;
        let slowMotionFactor = 1; // 1 = normal speed, higher values = slower
        let slowMotionDuration = 0;
        const MAX_SLOW_MOTION = 3; // Maximum slow motion factor

        // Combo system variables
        let comboCount = 0;
        let comboTimer = 0;
        const COMBO_TIME = 1500; // Time window for combos in milliseconds
        let comboTextScale = 1;
        let lastComboTime = 0;

        // Ball squash and stretch variables
        let ballSquashX = 1;
        let ballSquashY = 1;
        let ballSquashDuration = 0;

        // Powerup variables
        const powerups = [];
        const POWERUP_CHANCE = 0.2; // Increased chance to drop a powerup
        const POWERUP_SPEED = 2;
        const POWERUP_SIZE = 15;
        let isWidePaddleActive = false;
        let widePaddleTimeoutId = null;
        const WIDE_PADDLE_DURATION = 10000; // 10 seconds
        const WIDE_PADDLE_FACTOR = 1.5; // Paddle becomes 1.5x wider

        // New powerup types
        let isFireballActive = false;
        let fireballTimeoutId = null;
        const FIREBALL_DURATION = 8000; // 8 seconds
        let isMagnetActive = false;
        let magnetTimeoutId = null;
        const MAGNET_DURATION = 7000; // 7 seconds
        const MAGNET_STRENGTH = 0.3; // Strength of magnetic pull
        // Game variables
        let score = 0;
        let lives = 3;
        let gameRunning = false;
        let animationId;

        // Paddle properties
        const paddleHeight = 15;
        const initialPaddleWidth = 80; // Store initial width
        let paddleWidth = initialPaddleWidth; // Current paddle width
        let paddleX = (canvas.width - paddleWidth) / 2;

        // Ball properties
        const ballRadius = 10;
        let ballX = canvas.width / 2;
        let ballY = canvas.height - paddleHeight - ballRadius - 10;
        let ballSpeedX = 4;
        let ballSpeedY = -4;

        // Brick properties
        const brickRowCount = 8;
        const brickColumnCount = 14;
        const brickWidth = 50;
        const brickHeight = 22;
        const brickPadding = 6;
        const brickOffsetTop = 40;
        const brickOffsetLeft = 20;

        // Create bricks with different patterns and properties
        const bricks = [];
        const neonColors = [
          "#ff00ff", // Magenta
          "#00ffff", // Cyan
          "#ffff00", // Yellow
          "#ff3399", // Hot Pink
          "#00ff66", // Bright Green
          "#ff6600", // Orange
          "#ff33cc", // Hot Pink
          "#33ccff", // Bright Blue
          "#9900ff", // Purple
          "#ff0066", // Crimson
        ];

        // Create a more complex brick layout
        for (let c = 0; c < brickColumnCount; c++) {
          bricks[c] = [];
          for (let r = 0; r < brickRowCount; r++) {
            // Create different patterns and brick types
            let status = 1;
            let hitPoints = 1;
            let colorIndex = Math.floor(Math.random() * neonColors.length);
            let points = (brickRowCount - r) * 10; // Base points

            // Create a zigzag pattern in the middle rows
            if (r >= 2 && r <= 5) {
              if ((c + r) % 3 === 0) {
                status = 0; // Create gaps in the pattern
              }
            }

            // Create stronger bricks in the top rows
            if (r < 2) {
              hitPoints = 2; // Stronger bricks at the top
              points *= 2; // Double points for stronger bricks

              // Create a checkerboard pattern for top rows
              if ((c + r) % 2 === 0) {
                colorIndex = 0; // Magenta for checkerboard
              } else {
                colorIndex = 2; // Yellow for checkerboard
              }
            }

            // Create special bricks in specific positions
            if (
              (c === 3 || c === brickColumnCount - 4) &&
              (r === 3 || r === 5)
            ) {
              hitPoints = 3; // Extra strong bricks
              points *= 3; // Triple points
              colorIndex = 9; // Crimson color
            }

            // Create a diamond pattern in the center
            const centerCol = Math.floor(brickColumnCount / 2);
            const centerRow = Math.floor(brickRowCount / 2);
            const distFromCenter =
              Math.abs(c - centerCol) + Math.abs(r - centerRow);

            if (distFromCenter <= 2 && distFromCenter > 0) {
              colorIndex = 4; // Bright Green for diamond
              points *= 1.5; // Bonus points
            }

            // Create the brick with all properties
            bricks[c][r] = {
              x: c * (brickWidth + brickPadding) + brickOffsetLeft, // Initialize position immediately
              y: r * (brickHeight + brickPadding) + brickOffsetTop, // Initialize position immediately
              status: status,
              hitPoints: hitPoints,
              maxHitPoints: hitPoints, // Store original hit points for color calculation
              color: neonColors[colorIndex],
              points: Math.floor(points),
              special: hitPoints > 1, // Flag for special effects
            };
          }
        }

        // Particles for explosion effect
        const particles = [];

        // Powerup Class
        class Powerup {
          constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.size = POWERUP_SIZE;
            this.speedY = POWERUP_SPEED;
            this.color = this.getColor();
            this.symbol = this.getSymbol();
            this.rotation = 0;
            this.rotationSpeed = Math.random() * 0.1 - 0.05;
            this.pulseAmount = 0;
            this.pulseDirection = 1;
            this.glowSize = 0;
            this.glowDirection = 1;
            this.trailParticles = [];
            this.lastTrailTime = 0;
          }

          getColor() {
            switch (this.type) {
              case "widePaddle":
                return "#00ff66"; // Brighter Green
              case "extraLife":
                return "#ffff00"; // Yellow
              case "fireball":
                return "#ff4500"; // Orange-Red
              case "magnet":
                return "#cc66ff"; // Brighter Purple
              case "slowMotion":
                return "#00ffff"; // Cyan
              default:
                return "#ffffff"; // White
            }
          }

          getSymbol() {
            switch (this.type) {
              case "widePaddle":
                return "⟷"; // Double arrow
              case "extraLife":
                return "♥"; // Heart
              case "fireball":
                return "🔥"; // Fire
              case "magnet":
                return "⚡"; // Lightning bolt
              case "slowMotion":
                return "⏱️"; // Timer
              default:
                return "?";
            }
          }

          update() {
            this.y += this.speedY;
            this.rotation += this.rotationSpeed;

            // Pulse effect for size
            this.pulseAmount += 0.05 * this.pulseDirection;
            if (this.pulseAmount > 0.3 || this.pulseAmount < 0) {
              this.pulseDirection *= -1;
            }

            // Glow effect
            this.glowSize += 0.2 * this.glowDirection;
            if (this.glowSize > 15 || this.glowSize < 0) {
              this.glowDirection *= -1;
            }

            // Add trail particles
            const now = Date.now();
            if (now - this.lastTrailTime > 50) {
              // Add trail every 50ms
              this.addTrailParticle();
              this.lastTrailTime = now;
            }

            // Update trail particles
            for (let i = this.trailParticles.length - 1; i >= 0; i--) {
              const p = this.trailParticles[i];
              p.life -= 0.05;
              if (p.life <= 0) {
                this.trailParticles.splice(i, 1);
              }
            }
          }

          addTrailParticle() {
            this.trailParticles.push({
              x: this.x,
              y: this.y,
              size: this.size * 0.5,
              life: 1,
              color: this.color,
            });
          }

          draw() {
            // Draw trail particles
            for (const p of this.trailParticles) {
              ctx.globalAlpha = p.life * 0.3;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Save context for rotation
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);

            // Draw outer glow
            ctx.beginPath();
            ctx.arc(0, 0, this.size + this.glowSize, 0, Math.PI * 2);
            const outerGradient = ctx.createRadialGradient(
              0,
              0,
              this.size / 2,
              0,
              0,
              this.size + this.glowSize
            );
            outerGradient.addColorStop(0, this.color);
            outerGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
            ctx.fillStyle = outerGradient;
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;

            // Draw powerup
            const currentSize = this.size * (1 + this.pulseAmount);

            // Draw a glowing circle instead of a square
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);

            // Create radial gradient for the powerup
            const gradient = ctx.createRadialGradient(
              0,
              0,
              currentSize * 0.3,
              0,
              0,
              currentSize
            );
            gradient.addColorStop(0, "#ffffff");
            gradient.addColorStop(0.3, this.color);
            gradient.addColorStop(1, lightenDarkenColor(this.color, -30));

            ctx.fillStyle = gradient;
            ctx.fill();

            // Add a glowing border
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw symbol inside
            ctx.font = `bold ${currentSize}px Arial`;
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.symbol, 0, 0);

            // Restore context
            ctx.restore();
          }
        }

        function spawnPowerup(x, y) {
          if (Math.random() < POWERUP_CHANCE) {
            // Determine powerup type with weighted probabilities
            const rand = Math.random();
            let type;
            if (rand < 0.25) {
              type = "widePaddle";
            } else if (rand < 0.45) {
              type = "extraLife";
            } else if (rand < 0.65) {
              type = "fireball";
            } else if (rand < 0.85) {
              type = "magnet";
            } else {
              type = "slowMotion";
            }
            powerups.push(new Powerup(x, y, type));

            // Create a small burst of particles for powerup spawn
            createExplosion(x, y, "#ffffff", 15, 0.5);
          }
        }

        function updatePowerups() {
          for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            p.update();

            // Check collision with paddle
            const currentPaddleWidth = paddleWidth / paddleSquashFactor; // Use potentially squashed width for collision
            const currentPaddleX =
              paddleX + (initialPaddleWidth - currentPaddleWidth) / 2; // Use initial width to calculate center offset
            const paddleTopY =
              canvas.height - paddleHeight * paddleSquashFactor;

            if (
              p.y + p.size / 2 > paddleTopY &&
              p.y - p.size / 2 < canvas.height && // Check if it's above the bottom edge
              p.x + p.size / 2 > currentPaddleX &&
              p.x - p.size / 2 < currentPaddleX + currentPaddleWidth
            ) {
              activatePowerup(p.type);
              powerups.splice(i, 1); // Remove collected powerup
            } else if (p.y - p.size / 2 > canvas.height) {
              powerups.splice(i, 1); // Remove powerup if it goes off screen
            }
          }
        }

        function drawPowerups() {
          powerups.forEach((p) => p.draw());
        }

        function activatePowerup(type) {
          // Create particles for powerup collection
          createExplosion(ballX, ballY, "#ffffff", 60, 1.5);

          // Apply screen shake
          screenShakeIntensity = 5;
          screenShakeDuration = 8;

          // Show powerup text
          showPowerupText(type);

          switch (type) {
            case "widePaddle":
              if (widePaddleTimeoutId) clearTimeout(widePaddleTimeoutId);
              paddleWidth = initialPaddleWidth * WIDE_PADDLE_FACTOR;
              isWidePaddleActive = true;

              // Add special effect for wide paddle activation
              for (let i = 0; i < 30; i++) {
                const particle = new Particle(
                  paddleX + paddleWidth / 2,
                  canvas.height - paddleHeight,
                  "#00ff66"
                );
                particle.speedX = (Math.random() - 0.5) * 8;
                particle.speedY = -Math.random() * 5 - 2;
                particle.size = Math.random() * 6 + 3;
                particles.push(particle);
              }

              widePaddleTimeoutId = setTimeout(() => {
                paddleWidth = initialPaddleWidth;
                isWidePaddleActive = false;
                widePaddleTimeoutId = null;
              }, WIDE_PADDLE_DURATION);
              break;

            case "extraLife":
              lives++;
              livesElement.textContent = lives;
              // Create heart particles
              for (let i = 0; i < 40; i++) {
                const particle = new Particle(canvas.width / 2, 30, "#ff6b6b");
                particle.size = Math.random() * 10 + 5;
                particle.speedX = (Math.random() - 0.5) * 8;
                particle.speedY = Math.random() * 3 + 1;
                particle.gravity = 0.05;
                particles.push(particle);
              }
              break;

            case "fireball":
              if (fireballTimeoutId) clearTimeout(fireballTimeoutId);
              isFireballActive = true;

              // Add special effect for fireball activation
              for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 30 + 10;
                const particle = new Particle(
                  ballX + Math.cos(angle) * distance,
                  ballY + Math.sin(angle) * distance,
                  i % 2 === 0 ? "#ff4500" : "#ffcc00"
                );
                particle.speedX = Math.cos(angle) * (Math.random() * 3 + 2);
                particle.speedY = Math.sin(angle) * (Math.random() * 3 + 2);
                particle.gravity = -0.03; // Make fire particles rise
                particles.push(particle);
              }

              // Set a timeout to deactivate fireball
              fireballTimeoutId = setTimeout(() => {
                isFireballActive = false;
                fireballTimeoutId = null;
              }, FIREBALL_DURATION);
              break;

            case "magnet":
              if (magnetTimeoutId) clearTimeout(magnetTimeoutId);
              isMagnetActive = true;

              // Add special effect for magnet activation
              for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const particle = new Particle(ballX, ballY, "#cc66ff");
                particle.speedX = Math.cos(angle) * (Math.random() * 4 + 2);
                particle.speedY = Math.sin(angle) * (Math.random() * 4 + 2);
                particle.size = Math.random() * 5 + 2;
                particles.push(particle);
              }

              magnetTimeoutId = setTimeout(() => {
                isMagnetActive = false;
                magnetTimeoutId = null;
              }, MAGNET_DURATION);
              break;

            case "slowMotion":
              // Activate slow motion effect
              isSlowMotionActive = true;
              slowMotionFactor = MAX_SLOW_MOTION;
              slowMotionDuration = 120; // Frames of slow motion

              // Add special effect for slow motion activation - particles only, no screen dimming
              for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 100 + 50;
                const particle = new Particle(
                  canvas.width / 2 + Math.cos(angle) * distance,
                  canvas.height / 2 + Math.sin(angle) * distance,
                  "#00ffff"
                );
                particle.speedX = -Math.cos(angle) * (Math.random() * 2 + 1);
                particle.speedY = -Math.sin(angle) * (Math.random() * 2 + 1);
                particle.gravity = 0;
                particle.decay = 0.01;
                particles.push(particle);
              }
              break;
          }
        }

        function showPowerupText(type) {
          let text = "";
          let color = "";

          switch (type) {
            case "widePaddle":
              text = "WIDE PADDLE!";
              color = "#00ff66";
              break;
            case "extraLife":
              text = "+1 LIFE!";
              color = "#ffff00";
              break;
            case "fireball":
              text = "FIREBALL!";
              color = "#ff4500";
              break;
            case "magnet":
              text = "MAGNET!";
              color = "#cc66ff";
              break;
            case "slowMotion":
              text = "SLOW MOTION!";
              color = "#00ffff";
              break;
          }

          // Create floating text
          const textObj = {
            text: text,
            x: canvas.width / 2,
            y: canvas.height / 2,
            color: color,
            scale: 0,
            targetScale: 2.5,
            speedY: -2,
            rotation: -0.2 + Math.random() * 0.4,
            particles: [],
          };

          // Add particles that follow the text
          for (let i = 0; i < 20; i++) {
            textObj.particles.push({
              x: textObj.x + (Math.random() - 0.5) * 100,
              y: textObj.y + (Math.random() - 0.5) * 30,
              size: Math.random() * 4 + 2,
              speedX: (Math.random() - 0.5) * 2,
              speedY: (Math.random() - 0.5) * 2,
              color: color,
              alpha: Math.random() * 0.5 + 0.5,
              life: 1.0,
            });
          }

          // Animate the text
          function animateText() {
            if (
              textObj.scale >= textObj.targetScale &&
              textObj.y < canvas.height / 4
            )
              return;

            // Draw particles first
            for (const p of textObj.particles) {
              if (p.life <= 0) continue;

              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();

              // Update particle position
              p.x += p.speedX;
              p.y += p.speedY;
              p.life -= 0.02;
            }

            ctx.save();
            ctx.translate(textObj.x, textObj.y);
            ctx.rotate(textObj.rotation);
            ctx.scale(textObj.scale, textObj.scale);

            // Draw text with glow
            ctx.font = `bold 24px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Add glow effect
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;
            ctx.fillStyle = "#ffffff";
            ctx.fillText(textObj.text, 0, 0);

            // Draw text with color
            ctx.shadowBlur = 0;
            ctx.fillStyle = color;
            ctx.fillText(textObj.text, 0, 0);

            ctx.restore();

            // Update properties
            textObj.y += textObj.speedY;
            textObj.scale = Math.min(textObj.scale + 0.15, textObj.targetScale);
            textObj.rotation *= 0.95; // Gradually straighten text

            // Continue animation until text moves off screen or reaches target position
            if (textObj.y > 0 && textObj.scale < textObj.targetScale) {
              requestAnimationFrame(animateText);
            }
          }

          animateText();
        }
        class Particle {
          constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 5 + 2; // Increased size range
            this.gravity = 0.1; // Add gravity
            this.life = 1; // Use life instead of alpha for decay
            this.decay = Math.random() * 0.03 + 0.01; // Faster decay
            this.speedX = Math.random() * 8 - 4;
            this.speedY = Math.random() * 8 - 4;
            this.color = color;
            this.alpha = 0.8; // Start slightly transparent
            // Removed decay from constructor, using life now
          }

          update() {
            this.x += this.speedX;
            this.y += this.speedY;
            this.speedY += this.gravity; // Apply gravity
            this.life -= this.decay;
            this.alpha = this.life > 0 ? this.life * 0.8 : 0; // Fade out based on life
            this.speedX *= 0.98; // Slightly less friction
            // this.speedY *= 0.99; // Remove Y friction due to gravity
          }
          draw() {
            if (this.life <= 0) return; // Don't draw dead particles

            // Use a fixed opacity that doesn't dim the screen
            const visibleAlpha = Math.min(0.9, this.alpha);
            ctx.globalAlpha = visibleAlpha;
            ctx.beginPath();
            // Draw slightly elongated shape in direction of movement for speed effect
            const angle = Math.atan2(this.speedY, this.speedX);
            ctx.ellipse(
              this.x,
              this.y,
              this.size * 1.2,
              this.size * 0.8,
              angle,
              0,
              Math.PI * 2
            );
            ctx.fillStyle = this.color;
            ctx.fill();
            ctx.closePath(); // Optional here, but doesn't hurt
            ctx.globalAlpha = 1;
          }
        }

        function createExplosion(x, y, color, count = 50, speedMultiplier = 1) {
          // Increased default count, added speedMultiplier
          for (let i = 0; i < count; i++) {
            const particle = new Particle(x, y, color);
            particle.speedX *= speedMultiplier * (Math.random() * 1.5 + 0.5); // More varied speed
            particle.speedY *= speedMultiplier * (Math.random() * 1.5 + 0.5);
            particles.push(particle);
          }
        }

        function updateParticles() {
          for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();

            if (particles[i].life <= 0) {
              // Check life instead of alpha
              particles.splice(i, 1);
            }
          }
        }
        // Ball waiting state variables
        let ballWaitingForLaunch = false;
        let showContinueMessage = false;
        let continueMessageOpacity = 0;
        let continueMessageFadeIn = true;

        // Function to respawn the ball
        function respawnBall() {
          // Reset ball position to above the paddle
          ballWaitingForLaunch = true;

          // Clear trail
          ballTrail.length = 0;

          // Add respawn effect
          createExplosion(ballX, ballY, "#ffffff", 30, 1.2);

          // Show "Press Space to Continue" message with fade effect
          showContinueMessage = true;
          continueMessageOpacity = 0;
          continueMessageFadeIn = true;
        }

        // Function to launch the ball from paddle
        function launchBall() {
          if (ballWaitingForLaunch) {
            ballWaitingForLaunch = false;
            showContinueMessage = false;

            // Set initial ball velocity
            ballSpeedX = (Math.random() > 0.5 ? 1 : -1) * 4;
            ballSpeedY = -4; // Always move upward initially

            // Add launch effect
            createExplosion(ballX, ballY, "#ffffff", 20, 1);

            // Add screen shake for dramatic effect
            screenShakeIntensity = 2;
            screenShakeDuration = 5;
          }
        }

        // Function to draw continue message
        function drawContinueMessage() {
          if (showContinueMessage) {
            // Fade effect
            if (continueMessageFadeIn) {
              continueMessageOpacity += 0.03;
              if (continueMessageOpacity >= 1) {
                continueMessageOpacity = 1;
                continueMessageFadeIn = false;
              }
            } else {
              continueMessageOpacity -= 0.01;
              if (continueMessageOpacity <= 0.5) {
                continueMessageOpacity = 0.5;
                continueMessageFadeIn = true;
              }
            }

            ctx.save();
            ctx.globalAlpha = continueMessageOpacity;
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "#ffffff";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Add glow effect
            ctx.shadowColor = "#ff6b6b";
            ctx.shadowBlur = 15;

            // Draw text
            ctx.fillText(
              "PRESS SPACE TO CONTINUE",
              canvas.width / 2,
              canvas.height / 2
            );
            ctx.restore();
          }
        }
        // Controls
        let rightPressed = false;
        let leftPressed = false;
        let mouseControlActive = false;

        // Event listeners
        document.addEventListener("keydown", keyDownHandler);
        document.addEventListener("keyup", keyUpHandler);
        document.addEventListener("mousemove", mouseMoveHandler);
        startButton.addEventListener("click", startGame);
        // Remove duplicate listener
        // startButton.addEventListener("click", startGame);

        function keyDownHandler(e) {
          if (e.key === "Right" || e.key === "ArrowRight") {
            rightPressed = true;
          } else if (e.key === "Left" || e.key === "ArrowLeft") {
            leftPressed = true;
          } else if (e.key === " " || e.key === "Spacebar") {
            // Launch ball when space is pressed
            launchBall();
          }
        }

        function keyUpHandler(e) {
          if (e.key === "Right" || e.key === "ArrowRight") {
            rightPressed = false;
          } else if (e.key === "Left" || e.key === "ArrowLeft") {
            leftPressed = false;
          }
        }

        function mouseMoveHandler(e) {
          mouseControlActive = true;
          // Get canvas position relative to the window
          const canvasRect = canvas.getBoundingClientRect();
          // Calculate the relative X position within the canvas
          const relativeX = e.clientX - canvasRect.left;

          // Only update paddle position if the game is running
          if (
            gameRunning &&
            relativeX > paddleWidth / 2 &&
            relativeX < canvas.width - paddleWidth / 2 // Use current paddleWidth
          ) {
            paddleX = relativeX - paddleWidth / 2; // Use current paddleWidth
          }
        }

        function drawBall() {
          // Draw trail first
          for (let i = 0; i < ballTrail.length; i++) {
            const pos = ballTrail[i];
            const trailAlpha = (i / ballTrail.length) * 0.3; // Fade out

            // Draw trail with color based on powerups
            let trailColor = "rgba(255, 255, 255, " + trailAlpha + ")";
            if (isFireballActive) {
              // Create fire-like gradient for trail
              const fireColors = [
                `rgba(255, 50, 0, ${trailAlpha * 1.2})`,
                `rgba(255, 150, 0, ${trailAlpha})`,
                `rgba(255, 220, 0, ${trailAlpha * 0.8})`,
              ];
              trailColor = fireColors[i % 3];
            }

            ctx.beginPath();
            // Apply squash and stretch to trail too
            ctx.ellipse(
              pos.x,
              pos.y,
              ballRadius * (i / ballTrail.length) * ballSquashX,
              ballRadius * (i / ballTrail.length) * ballSquashY,
              Math.atan2(ballSpeedY, ballSpeedX),
              0,
              Math.PI * 2
            );
            ctx.fillStyle = trailColor;
            ctx.fill();
            ctx.closePath();
          }

          // Draw main ball with squash and stretch
          ctx.beginPath();
          ctx.ellipse(
            ballX,
            ballY,
            ballRadius * ballSquashX,
            ballRadius * ballSquashY,
            Math.atan2(ballSpeedY, ballSpeedX),
            0,
            Math.PI * 2
          );

          // Ball color/style based on powerups
          if (isFireballActive) {
            // Create fire gradient for ball
            const gradient = ctx.createRadialGradient(
              ballX,
              ballY,
              0,
              ballX,
              ballY,
              ballRadius * Math.max(ballSquashX, ballSquashY)
            );
            gradient.addColorStop(0, "#ffffff"); // White hot core
            gradient.addColorStop(0.2, "#ffff00"); // Yellow
            gradient.addColorStop(0.6, "#ff8c00"); // Orange middle
            gradient.addColorStop(1, "#ff4500"); // Red-orange outer
            ctx.fillStyle = gradient;

            // Add extra glow for fireball
            ctx.shadowColor = "#ff4500";
            ctx.shadowBlur = 25;

            // Add random fire particles
            if (Math.random() < 0.3) {
              const angle = Math.random() * Math.PI * 2;
              const distance = ballRadius * 0.8;
              const fireParticle = new Particle(
                ballX + Math.cos(angle) * distance,
                ballY + Math.sin(angle) * distance,
                Math.random() < 0.5 ? "#ff4500" : "#ffcc00"
              );
              fireParticle.speedX = Math.cos(angle) * (Math.random() * 2);
              fireParticle.speedY = Math.sin(angle) * (Math.random() * 2) - 1;
              fireParticle.gravity = -0.05;
              fireParticle.size = Math.random() * 3 + 1;
              fireParticle.decay = 0.05;
              particles.push(fireParticle);
            }
          } else {
            ctx.fillStyle = "#ffffff"; // Bright white ball
            ctx.shadowColor = "rgba(255, 255, 255, 0.8)"; // White glow
            ctx.shadowBlur = 15;
          }

          ctx.fill();
          ctx.closePath();

          // Draw magnet effect if active
          if (isMagnetActive) {
            ctx.beginPath();
            const magnetRadius = ballRadius * 3;
            const gradient = ctx.createRadialGradient(
              ballX,
              ballY,
              ballRadius,
              ballX,
              ballY,
              magnetRadius
            );
            // Use solid colors with no transparency to avoid dimming
            gradient.addColorStop(0, "#cc66ff");
            gradient.addColorStop(0.5, "#9966ff");
            gradient.addColorStop(1, "#6633cc");
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = "lighter"; // Use lighter blend mode instead of transparency
            ctx.arc(ballX, ballY, magnetRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = "source-over"; // Reset blend mode

            // Add electric arcs
            for (let i = 0; i < 3; i++) {
              if (Math.random() < 0.1) {
                const startAngle = Math.random() * Math.PI * 2;
                const arcLength = Math.PI / 6 + (Math.random() * Math.PI) / 6;

                ctx.beginPath();
                ctx.arc(
                  ballX,
                  ballY,
                  magnetRadius * 0.8,
                  startAngle,
                  startAngle + arcLength
                );
                ctx.strokeStyle = "#cc66ff";
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            }
            ctx.closePath();
          }

          // Reset shadow for other elements
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;

          // Gradually restore ball to normal shape if squashed
          if (ballSquashDuration > 0) {
            ballSquashDuration--;
            ballSquashX += (1 - ballSquashX) * 0.2;
            ballSquashY += (1 - ballSquashY) * 0.2;
          } else {
            ballSquashX = 1;
            ballSquashY = 1;
          }
        }

        function drawPaddle() {
          const currentPaddleHeight = paddleHeight * paddleSquashFactor;
          // Use the potentially modified paddleWidth for drawing
          const currentPaddleWidth = paddleWidth / paddleSquashFactor;
          const currentPaddleY = canvas.height - currentPaddleHeight;
          // Adjust X based on the *initial* width to keep it centered during squash/stretch
          const currentPaddleX =
            paddleX + (initialPaddleWidth - currentPaddleWidth) / 2;
          ctx.beginPath();
          ctx.rect(
            currentPaddleX,
            currentPaddleY,
            currentPaddleWidth,
            currentPaddleHeight
          );

          // Add gradient for juiciness
          const gradient = ctx.createLinearGradient(
            currentPaddleX,
            currentPaddleY,
            currentPaddleX,
            canvas.height
          );
          gradient.addColorStop(0, "#63e6be"); // Teal top
          gradient.addColorStop(1, "#12b886"); // Darker teal bottom
          ctx.fillStyle = gradient;
          ctx.fill();
          ctx.closePath();

          // Add subtle highlight
          ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
          ctx.fillRect(
            currentPaddleX + 2,
            currentPaddleY + 2,
            currentPaddleWidth - 4,
            3
          );

          // Add shadow for depth
          ctx.shadowColor = "rgba(0, 0, 0, 0.4)";
          ctx.shadowBlur = 8;
          ctx.shadowOffsetY = 3;
          ctx.fillStyle = gradient; // Need to re-apply fillStyle for shadow to work correctly on fill
          ctx.fillRect(
            currentPaddleX,
            currentPaddleY,
            currentPaddleWidth,
            currentPaddleHeight
          );
          // Reset shadow
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.shadowOffsetY = 0;
        }

        function drawBricks() {
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              const brick = bricks[c][r];
              if (brick.status === 1) {
                // Only calculate positions if they haven't been set yet
                if (brick.x === 0 && brick.y === 0) {
                  brick.x = c * (brickWidth + brickPadding) + brickOffsetLeft;
                  brick.y = r * (brickHeight + brickPadding) + brickOffsetTop;
                }

                const brickX = brick.x;
                const brickY = brick.y;

                // Add glow effect - stronger for special bricks
                ctx.shadowColor = brick.color;
                ctx.shadowBlur = brick.special ? 20 : 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Draw brick with rounded corners
                ctx.beginPath();
                const radius = brick.special ? 6 : 4; // Larger radius for special bricks
                ctx.moveTo(brickX + radius, brickY);
                ctx.lineTo(brickX + brickWidth - radius, brickY);
                ctx.arcTo(
                  brickX + brickWidth,
                  brickY,
                  brickX + brickWidth,
                  brickY + radius,
                  radius
                );
                ctx.lineTo(brickX + brickWidth, brickY + brickHeight - radius);
                ctx.arcTo(
                  brickX + brickWidth,
                  brickY + brickHeight,
                  brickX + brickWidth - radius,
                  brickY + brickHeight,
                  radius
                );
                ctx.lineTo(brickX + radius, brickY + brickHeight);
                ctx.arcTo(
                  brickX,
                  brickY + brickHeight,
                  brickX,
                  brickY + brickHeight - radius,
                  radius
                );
                ctx.lineTo(brickX, brickY + radius);
                ctx.arcTo(brickX, brickY, brickX + radius, brickY, radius);
                ctx.closePath();

                // Create gradient based on brick color and hit points
                const gradient = ctx.createLinearGradient(
                  brickX,
                  brickY,
                  brickX,
                  brickY + brickHeight
                );

                // For multi-hit bricks, show visual indication of remaining strength
                if (brick.hitPoints > 1) {
                  // Create a metallic effect for stronger bricks
                  gradient.addColorStop(0, lightenDarkenColor(brick.color, 30));
                  gradient.addColorStop(0.5, brick.color);
                  gradient.addColorStop(
                    1,
                    lightenDarkenColor(brick.color, -30)
                  );

                  // Add a pattern or indicator for multi-hit bricks
                  ctx.fillStyle = gradient;
                  ctx.fill();

                  // Draw hit point indicators
                  for (let i = 0; i < brick.hitPoints; i++) {
                    const dotX =
                      brickX +
                      brickWidth / 2 +
                      (i - (brick.hitPoints - 1) / 2) * 6;
                    const dotY = brickY + brickHeight - 5;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 2, 0, Math.PI * 2);
                    ctx.fillStyle = "#ffffff";
                    ctx.fill();
                  }
                } else {
                  // Normal single-hit bricks
                  gradient.addColorStop(0, brick.color);
                  const darkerColor = lightenDarkenColor(brick.color, -30);
                  gradient.addColorStop(1, darkerColor);
                  ctx.fillStyle = gradient;
                  ctx.fill();
                }

                // Add inner glow
                const innerGlow = ctx.createLinearGradient(
                  brickX + brickWidth / 2,
                  brickY,
                  brickX + brickWidth / 2,
                  brickY + brickHeight
                );
                innerGlow.addColorStop(0, "rgba(255, 255, 255, 0.5)");
                innerGlow.addColorStop(0.5, "rgba(255, 255, 255, 0.1)");
                innerGlow.addColorStop(1, "rgba(255, 255, 255, 0)");

                // Draw inner highlight
                ctx.beginPath();
                ctx.roundRect(
                  brickX + 3,
                  brickY + 3,
                  brickWidth - 6,
                  brickHeight - 6,
                  radius - 1
                );
                ctx.fillStyle = innerGlow;
                ctx.fill();

                // Reset shadow for other elements
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
              }
            }
          }
        }
        // Draw combo text if active
        function drawComboText() {
          if (comboCount > 1 && comboTimer > 0) {
            const fontSize = 20 * comboTextScale;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Create gradient for combo text
            const gradient = ctx.createLinearGradient(
              canvas.width / 2 - 50,
              canvas.height / 2,
              canvas.width / 2 + 50,
              canvas.height / 2
            );
            gradient.addColorStop(0, "#ff0066");
            gradient.addColorStop(0.5, "#ffcc00");
            gradient.addColorStop(1, "#33ccff");

            ctx.fillStyle = gradient;
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 3;

            const comboText = `${comboCount}x COMBO!`;
            const y = canvas.height / 4;

            // Add glow effect
            ctx.shadowColor = "#ffffff";
            ctx.shadowBlur = 10;

            // Draw text with outline
            ctx.strokeText(comboText, canvas.width / 2, y);
            ctx.fillText(comboText, canvas.width / 2, y);

            // Reset shadow
            ctx.shadowColor = "transparent";
            ctx.shadowBlur = 0;

            // Update combo timer and scale
            comboTimer -= 16; // Assuming ~60fps
            comboTextScale = Math.max(1, comboTextScale * 0.95);
          }
        }

        // Function to update slow motion effect
        function updateSlowMotion() {
          if (isSlowMotionActive) {
            if (slowMotionDuration > 0) {
              // Add occasional time ripple effect without dimming the screen
              if (Math.random() < 0.05) {
                const ripple = {
                  x: ballX,
                  y: ballY,
                  radius: 5,
                  maxRadius: 100,
                  alpha: 0.5,
                };

                function drawRipple() {
                  if (ripple.alpha <= 0) return;

                  ctx.beginPath();
                  ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                  ctx.strokeStyle = `rgba(0, 255, 255, ${ripple.alpha})`;
                  ctx.lineWidth = 2;
                  ctx.stroke();

                  ripple.radius += 3;
                  ripple.alpha -= 0.02;

                  if (ripple.radius < ripple.maxRadius) {
                    requestAnimationFrame(drawRipple);
                  }
                }

                drawRipple();
              }

              // Gradually return to normal speed
              if (slowMotionDuration < 30) {
                slowMotionFactor = Math.max(1, slowMotionFactor - 0.1);
              }

              slowMotionDuration--;
            } else {
              isSlowMotionActive = false;
              slowMotionFactor = 1;
            }
          }
        }

        // Helper function to lighten/darken a hex color
        function lightenDarkenColor(col, amt) {
          let usePound = false;
          if (col[0] == "#") {
            col = col.slice(1);
            usePound = true;
          }
          const num = parseInt(col, 16);
          let r = (num >> 16) + amt;
          if (r > 255) r = 255;
          else if (r < 0) r = 0;
          let b = ((num >> 8) & 0x00ff) + amt;
          if (b > 255) b = 255;
          else if (b < 0) b = 0;
          let g = (num & 0x0000ff) + amt;
          if (g > 255) g = 255;
          else if (g < 0) g = 0;
          return (
            (usePound ? "#" : "") +
            (g | (b << 8) | (r << 16)).toString(16).padStart(6, "0")
          );
        }

        function collisionDetection() {
          let brickHit = false;
          let bricksHitThisFrame = 0;
          let bricksRemaining = 0;

          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              const b = bricks[c][r];
              if (b.status > 0) {
                bricksRemaining++;
                // Check for collision with brick
                const brickHitbox = {
                  left: b.x - ballRadius,
                  right: b.x + brickWidth + ballRadius,
                  top: b.y - ballRadius,
                  bottom: b.y + brickHeight + ballRadius,
                };

                if (
                  ballX > brickHitbox.left &&
                  ballX < brickHitbox.right &&
                  ballY > brickHitbox.top &&
                  ballY < brickHitbox.bottom
                ) {
                  // Fireball destroys bricks without bouncing
                  if (isFireballActive) {
                    b.status = 0;
                    brickHit = true;
                    bricksHitThisFrame++;
                    score += b.points; // Add the brick's points to score

                    // Create more intense explosion for fireball
                    const explosionX = b.x + brickWidth / 2;
                    const explosionY = b.y + brickHeight / 2;
                    createExplosion(explosionX, explosionY, b.color, 80, 1.5);

                    // Add fire trail particles
                    for (let i = 0; i < 10; i++) {
                      const fireParticle = new Particle(
                        explosionX,
                        explosionY,
                        "#ff4500"
                      );
                      fireParticle.speedX = (Math.random() - 0.5) * 3;
                      fireParticle.speedY = (Math.random() - 0.5) * 3;
                      fireParticle.gravity = -0.05; // Fire rises
                      fireParticle.decay = 0.03;
                      particles.push(fireParticle);
                    }

                    // Spawn Powerup Check for fireball hits too
                    spawnPowerup(explosionX, explosionY);

                    // Continue ball movement (no bounce)
                    continue;
                  }

                  // Normal brick collision (non-fireball)
                  // Determine collision side (simplified)
                  const overlapX =
                    ballRadius +
                    brickWidth / 2 -
                    Math.abs(ballX - (b.x + brickWidth / 2));
                  const overlapY =
                    ballRadius +
                    brickHeight / 2 -
                    Math.abs(ballY - (b.y + brickHeight / 2));

                  if (overlapX >= overlapY) {
                    // Horizontal collision likely
                    ballSpeedY = -ballSpeedY;
                    // Nudge ball slightly out of collision vertically
                    ballY += Math.sign(ballSpeedY) * 2;

                    // Apply ball squash on vertical collision
                    ballSquashX = 1.3;
                    ballSquashY = 0.7;
                    ballSquashDuration = 5;
                  } else {
                    // Vertical collision likely
                    ballSpeedX = -ballSpeedX;
                    // Nudge ball slightly out of collision horizontally
                    ballX += Math.sign(ballSpeedX) * 2;

                    // Apply ball squash on horizontal collision
                    ballSquashX = 0.7;
                    ballSquashY = 1.3;
                    ballSquashDuration = 5;
                  }

                  // Handle multi-hit bricks
                  if (b.hitPoints > 1) {
                    b.hitPoints--;

                    // Calculate a "damaged" color based on remaining hit points
                    const hitRatio = b.hitPoints / b.maxHitPoints;
                    const baseColor = b.color;
                    const darkerColor = lightenDarkenColor(
                      baseColor,
                      -30 * (1 - hitRatio)
                    );
                    b.color = darkerColor;

                    // Create a smaller explosion for a hit that doesn't destroy the brick
                    const explosionX = b.x + brickWidth / 2;
                    const explosionY = b.y + brickHeight / 2;
                    createExplosion(explosionX, explosionY, b.color, 30, 0.8);

                    // Add some points even for non-destroying hits
                    score += Math.floor(b.points * 0.2);

                    // Still count as a brick hit for combo system
                    brickHit = true;
                    bricksHitThisFrame++;
                  } else {
                    // Destroy the brick
                    b.status = 0;
                    brickHit = true;
                    bricksHitThisFrame++;
                    score += b.points; // Add the brick's points to score

                    // Create explosion effect at the brick's center
                    const explosionX = b.x + brickWidth / 2;
                    const explosionY = b.y + brickHeight / 2;

                    // Special bricks get more spectacular explosions
                    if (b.special) {
                      createExplosion(
                        explosionX,
                        explosionY,
                        b.color,
                        100,
                        1.5
                      );
                      // Add extra screen shake for special bricks
                      screenShakeIntensity += 2;
                      screenShakeDuration += 5;
                    } else {
                      createExplosion(explosionX, explosionY, b.color, 60, 1.2);
                    }

                    // Spawn Powerup Check - higher chance for special bricks
                    if (b.special) {
                      // Force powerup spawn for special bricks
                      const rand = Math.random();
                      let type;
                      if (rand < 0.25) {
                        type = "widePaddle";
                      } else if (rand < 0.5) {
                        type = "extraLife";
                      } else if (rand < 0.75) {
                        type = "fireball";
                      } else if (rand < 0.9) {
                        type = "magnet";
                      } else {
                        type = "slowMotion";
                      }
                      powerups.push(new Powerup(explosionX, explosionY, type));
                      createExplosion(
                        explosionX,
                        explosionY,
                        "#ffffff",
                        15,
                        0.5
                      );
                    } else {
                      spawnPowerup(explosionX, explosionY);
                    }
                  }
                }
              }
            }
          }

          // If any bricks were hit this frame
          if (brickHit) {
            // Update combo system
            const now = Date.now();
            if (now - lastComboTime < COMBO_TIME) {
              comboCount++;
              // Increase combo text scale for visual feedback
              comboTextScale = 1.5;
            } else {
              comboCount = 1;
            }

            if (comboCount > 1) {
              // Add bonus points for combos
              const comboBonus = (comboCount - 1) * 5;
              score += comboBonus;

              // Reset combo timer
              comboTimer = COMBO_TIME;
            }

            lastComboTime = now;

            // Score Pop Effect
            scorePopScale = 1.4;
            scoreElement.style.transform = `scale(${scorePopScale})`;
            scoreElement.style.transition = "transform 0.1s ease-out";
            scoreElement.textContent = score;

            // Screen Shake Effect
            screenShakeIntensity = 3 + Math.min(7, comboCount);
            screenShakeDuration = 5 + Math.min(10, comboCount);

            // Activate slow motion on high combos
            if (comboCount >= 3 && !isSlowMotionActive) {
              isSlowMotionActive = true;
              slowMotionFactor = Math.min(
                MAX_SLOW_MOTION,
                1 + comboCount * 0.2
              );
              slowMotionDuration = 30 + comboCount * 5;
              // No screen overlay for slow motion
            }

            // Check if all bricks are gone
            if (bricksRemaining === 0) {
              showWinMessage();
              gameRunning = false;
              cancelAnimationFrame(animationId);
              // Ensure canvas transform is reset on win
              canvas.style.transform = "translate(0, 0)";
            }
          }
        }
        // This function is no longer used since we're directly counting bricks
        function calculateMaxScore() {
          let maxScore = 0;
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              maxScore += bricks[c][r].points;
            }
          }
          return maxScore;
        }

        function showWinMessage() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.font = "30px Arial";
          ctx.fillStyle = "#ff6b6b";
          ctx.textAlign = "center";
          ctx.fillText("YOU WIN!", canvas.width / 2, canvas.height / 2 - 30);
          ctx.font = "20px Arial";
          ctx.fillStyle = "white";
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2,
            canvas.height / 2 + 10
          );
          startButton.textContent = "Play Again";
          startButton.style.display = "block";
        }

        function showGameOver() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Ensure canvas transform is reset on game over
          canvas.style.transform = "translate(0, 0)";
          ctx.font = "bold 48px Arial"; // Bolder font
          ctx.fillStyle = "#e03131"; // Darker red
          ctx.textAlign = "center";
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.shadowBlur = 10;
          ctx.shadowOffsetY = 5;
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);
          ctx.font = "24px Arial"; // Larger score font
          ctx.fillStyle = "white";
          ctx.shadowColor = "transparent"; // Reset shadow for score
          ctx.shadowBlur = 0;
          ctx.shadowOffsetY = 0;
          ctx.fillText(
            `Final Score: ${score}`,
            canvas.width / 2,
            canvas.height / 2 + 20
          );
          startButton.textContent = "Try Again";
          startButton.style.display = "block";
        }

        function draw() {
          if (!gameRunning) return;

          // Apply slow motion if active
          const effectiveSpeedFactor = isSlowMotionActive
            ? 1 / slowMotionFactor
            : 1;

          // Apply screen shake
          let shakeX = 0;
          let shakeY = 0;
          if (screenShakeDuration > 0) {
            shakeX = (Math.random() - 0.5) * 2 * screenShakeIntensity;
            shakeY = (Math.random() - 0.5) * 2 * screenShakeIntensity;
            canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            screenShakeDuration--;
          } else {
            canvas.style.transform = "translate(0, 0)"; // Reset transform when shake ends
          }

          // Apply score pop decay
          if (scorePopScale > 1) {
            scorePopScale -= 0.05; // Decay speed
            scoreElement.style.transform = `scale(${Math.max(1, scorePopScale)})`;
          } else {
            // Ensure transition is removed or reset after pop
            scoreElement.style.transition = "transform 0.1s ease-out"; // Keep transition for potential future pops
          }

          // Apply paddle squash decay
          if (paddleSquashDuration > 0) {
            paddleSquashFactor += 0.08; // Speed of returning to normal
            if (paddleSquashFactor >= 1) {
              paddleSquashFactor = 1;
              paddleSquashDuration = 0;
            }
          }

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Update slow motion effect without dimming
          updateSlowMotion();

          // Draw game elements in the correct order
          drawBricks();
          drawPowerups(); // Draw powerups before ball
          updateParticles(); // Draw and update particles
          drawBall();
          drawPaddle();
          updatePowerups(); // Update powerups and check collisions
          drawComboText(); // Draw combo text if active
          drawContinueMessage(); // Draw continue message if needed
          collisionDetection();

          // Ball movement and collision with walls
          if (
            ballX + ballSpeedX > canvas.width - ballRadius ||
            ballX + ballSpeedX < ballRadius
          ) {
            ballSpeedX = -ballSpeedX;
            // Wall hit particles
            const now = Date.now();
            if (now - lastWallHitTime > WALL_HIT_COOLDOWN) {
              createExplosion(
                ballX + Math.sign(ballSpeedX) * ballRadius,
                ballY,
                "#cccccc",
                15,
                0.5
              ); // White particles, fewer, slower
              lastWallHitTime = now;
              // Subtle screen shake on wall hit
              screenShakeIntensity = 1;
              screenShakeDuration = 3;
            }
          } // End side wall collision check

          if (ballY + ballSpeedY < ballRadius) {
            ballSpeedY = -ballSpeedY;
            // Wall hit particles (top wall)
            const now = Date.now();
            if (now - lastWallHitTime > WALL_HIT_COOLDOWN) {
              createExplosion(
                ballX,
                ballY + Math.sign(ballSpeedY) * ballRadius,
                "#cccccc",
                15,
                0.5
              );
              lastWallHitTime = now;
              // Subtle screen shake on wall hit
              screenShakeIntensity = 1;
              screenShakeDuration = 3;
            }
          } else if (
            !ballWaitingForLaunch && // Only check paddle collision if ball is in motion
            ballY + ballSpeedY >
              canvas.height - ballRadius - paddleHeight * paddleSquashFactor && // Check if ball is at paddle height
            ballSpeedY > 0 // Only check paddle collision if ball is moving downward
          ) {
            // Check paddle collision considering squashed height
            const paddleTopY =
              canvas.height - paddleHeight * paddleSquashFactor;
            const currentPaddleWidth = paddleWidth / paddleSquashFactor;
            const currentPaddleX =
              paddleX + (paddleWidth - currentPaddleWidth) / 2;

            if (
              ballX > currentPaddleX &&
              ballX < currentPaddleX + currentPaddleWidth
            ) {
              // Calculate bounce angle based on where ball hits paddle
              const hitPosition = (ballX - currentPaddleX) / currentPaddleWidth;
              // Map hit position to angle: center is straight up (-PI/2), edges are steeper
              const maxAngleOffset = Math.PI / 3; // Max angle change (e.g., 60 degrees from vertical)
              const angle =
                (hitPosition - 0.5) * 2 * maxAngleOffset - Math.PI / 2;

              const currentSpeed = Math.sqrt(
                ballSpeedX * ballSpeedX + ballSpeedY * ballSpeedY
              );
              const newSpeed = currentSpeed * 1.02; // Slightly increase speed on paddle hit

              ballSpeedX = Math.cos(angle) * newSpeed;
              ballSpeedY = Math.sin(angle) * newSpeed; // Use sin for Y, ensures upward direction

              // Ensure ball is moving upward after paddle hit
              if (ballSpeedY > 0) {
                ballSpeedY = -ballSpeedY;
              }

              // Paddle Squash Effect
              paddleSquashFactor = 0.8; // Squash more
              paddleSquashDuration = 5; // Duration of squash effect (in frames)

              // Paddle Hit Particles
              const paddleHitNow = Date.now();
              if (paddleHitNow - lastPaddleHitTime > PADDLE_HIT_COOLDOWN) {
                createExplosion(ballX, paddleTopY, "#63e6be", 25, 0.8); // Paddle color particles
                lastPaddleHitTime = paddleHitNow;
              }

              // Paddle Hit Screen Shake
              screenShakeIntensity = 2;
              screenShakeDuration = 5;
            } else if (ballY + ballSpeedY > canvas.height - ballRadius) {
              // Ball missed the paddle and hit the bottom
              lives--;
              livesElement.textContent = lives;

              // Create explosion effect for ball loss
              createExplosion(ballX, ballY, "#ff6b6b", 40, 1.2); // Red explosion for ball loss

              // Screen shake for ball loss
              screenShakeIntensity = 4;
              screenShakeDuration = 10;

              if (lives === 0) {
                showGameOver();
                gameRunning = false;
                return;
              } else {
                // Respawn the ball
                respawnBall();
              }
            }
          } else if (
            ballY + ballSpeedY > canvas.height - ballRadius &&
            !ballWaitingForLaunch
          ) {
            // Ball has gone past the bottom of the screen without hitting paddle
            lives--;
            livesElement.textContent = lives;

            // Create explosion effect for ball loss
            createExplosion(ballX, ballY, "#ff6b6b", 40, 1.2); // Red explosion for ball loss

            // Screen shake for ball loss
            screenShakeIntensity = 4;
            screenShakeDuration = 10;

            if (lives === 0) {
              showGameOver();
              gameRunning = false;
              return;
            } else {
              // Respawn the ball
              respawnBall();
            }
          }

          // Handle ball waiting for launch
          if (ballWaitingForLaunch) {
            // Position ball above paddle
            ballX = paddleX + paddleWidth / 2;
            ballY = canvas.height - paddleHeight - ballRadius - 2;

            // Clear any existing trail
            ballTrail.length = 0;
          }

          // Paddle movement
          if (!mouseControlActive) {
            if (rightPressed && paddleX < canvas.width - initialPaddleWidth) {
              // Use initial width for boundary check
              paddleX += 7;
            } else if (leftPressed && paddleX > 0) {
              paddleX -= 7;
            }
          }

          // Reset mouse control flag
          mouseControlActive = false;

          // Update ball position if not waiting for launch
          if (!ballWaitingForLaunch) {
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            // Update ball trail
            ballTrail.push({ x: ballX, y: ballY });
            if (ballTrail.length > MAX_TRAIL_LENGTH) {
              ballTrail.shift(); // Remove the oldest position
            }
          }

          animationId = requestAnimationFrame(draw);
        }

        function startGame() {
          // Reset game state
          score = 0;
          lives = 3;
          scoreElement.textContent = score;
          livesElement.textContent = lives;

          // Reset paddle and ball
          // Reset paddle and ball
          paddleWidth = initialPaddleWidth;
          paddleX = (canvas.width - paddleWidth) / 2;
          ballX = canvas.width / 2;
          ballY = canvas.height - paddleHeight - ballRadius - 10;
          ballSpeedX = 0;
          ballSpeedY = 0;
          ballWaitingForLaunch = true; // Start with ball waiting for launch

          // Clear any existing particles, trail, and powerups
          particles.length = 0;
          ballTrail.length = 0;
          powerups.length = 0; // Clear powerups array

          // Reset powerup effects
          if (widePaddleTimeoutId) clearTimeout(widePaddleTimeoutId);
          if (fireballTimeoutId) clearTimeout(fireballTimeoutId);
          if (magnetTimeoutId) clearTimeout(magnetTimeoutId);

          paddleWidth = initialPaddleWidth;
          isWidePaddleActive = false;
          isFireballActive = false;
          isMagnetActive = false;
          isSlowMotionActive = false;

          widePaddleTimeoutId = null;
          fireballTimeoutId = null;
          magnetTimeoutId = null;

          // Reset combo system
          comboCount = 0;
          comboTimer = 0;
          lastComboTime = 0;

          // Reset ball squash
          ballSquashX = 1;
          ballSquashY = 1;
          ballSquashDuration = 0;

          // Reset bricks
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              // Restore original brick status and hit points
              if (bricks[c][r].maxHitPoints) {
                bricks[c][r].status = 1;
                bricks[c][r].hitPoints = bricks[c][r].maxHitPoints;

                // Reset color if it was changed due to damage
                const colorIndex = Math.floor(
                  Math.random() * neonColors.length
                );
                if (bricks[c][r].special) {
                  // Keep special brick colors consistent
                  if (r < 2) {
                    // Checkerboard pattern for top rows
                    bricks[c][r].color =
                      (c + r) % 2 === 0 ? neonColors[0] : neonColors[2];
                  } else if (
                    (c === 3 || c === brickColumnCount - 4) &&
                    (r === 3 || r === 5)
                  ) {
                    bricks[c][r].color = neonColors[9]; // Crimson for special corner bricks
                  } else {
                    // Diamond pattern in center
                    const centerCol = Math.floor(brickColumnCount / 2);
                    const centerRow = Math.floor(brickRowCount / 2);
                    const distFromCenter =
                      Math.abs(c - centerCol) + Math.abs(r - centerRow);
                    if (distFromCenter <= 2 && distFromCenter > 0) {
                      bricks[c][r].color = neonColors[4]; // Green for diamond
                    } else {
                      bricks[c][r].color = neonColors[colorIndex];
                    }
                  }
                } else {
                  bricks[c][r].color = neonColors[colorIndex];
                }
              }
            }
          }

          // Hide start button
          startButton.style.display = "none";

          // Start game loop
          gameRunning = true;
          draw();
        }

        // Initial draw to show the game before starting
        function initialDraw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Reset potential lingering effects from previous game over/win screens
          canvas.style.transform = "translate(0, 0)";
          scoreElement.style.transform = "scale(1)";
          paddleSquashFactor = 1;
          screenShakeDuration = 0;
          scorePopScale = 1;
          ballTrail.length = 0;
          particles.length = 0;
          powerups.length = 0; // Clear powerups on initial draw too

          // Initialize brick positions before drawing
          for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
              const brick = bricks[c][r];
              if (brick.status === 1) {
                brick.x = c * (brickWidth + brickPadding) + brickOffsetLeft;
                brick.y = r * (brickHeight + brickPadding) + brickOffsetTop;
              }
            }
          }

          drawBricks();
          drawBall(); // Draw ball in initial position
          drawPaddle(); // Draw paddle in initial position
        }
        initialDraw(); // Call initial draw
      });
    </script>
  </body>
</html>
